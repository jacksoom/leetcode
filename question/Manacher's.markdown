Algorithm Manacher's
problem：给定一个字符串,找出字符串的最长回文子串
算法思路：
step1:预处理子字符串，解决回文子串长度奇偶问题
该思路是中心检测法一个升级。所有的空隙位置（包括首尾）插入同样的符号（在字符串中没有出现过的，例如 #）,
然后对处理过的字符串采用中心化检测法，取最大就得出我们想要的结果
中心化检测法就是以字符串中的每一个字符为中心点，将其两侧的字符比较。但是如果不处理，就需要考虑其为偶数长度 
e.g. "aba"这个可以用中心化检测，"baab"就不能用中心化检测了。

处理之前：str1=abaaba 
处理之后：T=#a#b#a#a#b#a#
现在我们遍历str2中的每一个字符(包含#)，中心化检测他们的回文字符串
e.g.T = # a # b # a # a # b # a #
    P = 0 1 0 3 0 1 6 1 0 3 0 1 0  (P数组是处理之后每个字符串对应的回文串长度，有的博客是从1开始，我这里是从0开始，结果不用减一)
    我们就以P[3]=3为例来解释。T[3]=b,开始中心化检测，T[2]=T[4]且T[1]=T[5],T[0]=T[6],所以P[3]=3
现在目的很明确了，就是求P

step2：求P数组过程：
    确定两个变量
            一个是在遍历每个字符串时候，记录之前的字符扫到了最右的位置(max-right)例如我们上面P[3]比起之前的最远，是6（注意不是7）,同时记录以此对应的字符下标max-id=3(从'b'扫到这里的)
            max-right 和 max-id
    遍历三大判断全过程：
        for(int i=0;i<T.length;i++) 遍历字符串每个字符
            step:判断当前字符的i是否小于或等于max-right。换句话说就是当前这个字符有没有被以前计算出来的回文数包括在内。
                 如果小于：
                      找出i关于当前max-id对称的点j,例如：例如i=5,max-id=3,j=1,然后我们要判断j被求出来的P[i]是否完全包含在max-id对应的回文串中
                                                   
